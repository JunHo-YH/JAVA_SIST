package com.sist.main;
/*
 * 	객체지향 프로그램: 유지보수가 가능하게 만드는 프로그램
 *                =======
 *                1) 데이터 보호: 캡슐화
 *                   => 멤버변수는 private으로 은닉화
 *                   => 접근 => getter / setter
 *                   => 멤버변수는 감추고 메서드를 통해서 접근하는 방식
 *                   멤버변수: private
 *                   멤버메서드: public
 *                   생성자: 모든 클래스에서 접속이 가능: public
 *                   ** 상속이 있는 경우에는 멤버변수는 protected
 *                      === 상속이 가능 (public, protected, default)
 *                      === 라이브러리를 변경
 *                2) 기존의 클래스를 재사용: is-a(상속), has-a(포함):웹에서는 포함관계를 주로 사용한다.
 *                     상속: 상속을 내리는 클래스(상위 클래스)의 모든 내용이 내려간다
 *                          예외) 생성자, static (사용이 가능하게 만들어준다)
 *                          => 키워드: extends(확장)
 *                          기존의 클래스를 확장해서 새로운 클래스를 만들어서 사용
 *                     class A {
 *                         내용(멤버변수, 멤버메서드)
 *                     }
 *                     class B extends A {
 *                         A가 가지고 있는 모든 내용을 받는다. (소스코드에서 보이지 않는다): 중복 제거, 소스를 간결하게
 *                         추가, 변경 => 사용이 가능
 *                     }
 *                     
 *                     포함: 기존의 클래스의 기능을 그대로 사용
 *                     class A {
 *                         내용(멤버변수, 멤버메서드)
 *                     }
 *                     class B{
 *                         A a = new A();
 *                     }
 *                     예)
 *                         윈도우, 버튼, 텍스트필드
 *                         ===== 윈도우 약간의 변경사항이 존재
 *                         ===== 자바에서 상속 단일 상속 (가장 큰것을 받아서 사용)
 *                         ===== 상속: 윈도우프로그램, 쓰레드
 *                               POJO (스프링 2.5이상): 독립클래스 (컴포넌트) => 컨테이너
 *                3) 변경, 추가 (다형성)
 *                  ====  ====
 *               오버라이딩 오버로딩
 *               
 *               ===================================================
 *                           오버로딩              오버라이딩              
 *               ===================================================
 *                상속여부   자신의 클래스             상속 (기존의 클래스의 기능을 결정)
 *               ===================================================
 *                메서드명      동일                 동일
 *               ===================================================
 *                매개변수   개수나 데이터형이 다르다     매개변수가 동일
 *               ===================================================
 *                리턴형      상관없다                동일
 *                                              * 접속지정어의 확장이 가능
 *                                                ========
 *                                                private < (default) < protected < public
 *                                                private: 자신의 클래스안에서만 접근
 *                                                default & private
 *                                                         같은 패키지안에서만 접근이 가능
 *                                                protected & default
 *                                                         다른 패키지에서 접근이 가능
 *                                                         단, 상속을 받은 경우에만 가능
 *                                                public: 모든 클래스에서 가능하다
 *               ===================================================
 * 1. 캡슐화 => 접근지정어, 2. 상속 => 오버라이딩
 * 2. 자신의 클래스를 지정하는 키워드: this
 *    상위 클래스를 지정하는 키워드: super
 *    => 자신의 생성자 호출: this()
 *    => 상위 클래스의 생성자 호출: super()
 *    
 * 3. 메서드의 정의
 *    static : static멤버변수는 언제든지 사용이 가능
 *             instance를 호출시에는 반드시 객체를 생성하고 접근
 *             class A {
 *                 private int x;
 *                 public static void dispaly() {
 *                     System.out.println("x" + x) ==> 에러
 *                     
 *                     A a = new A();
 *                     System.out.println("X" + a.x)
 *                 }
 *             
 *             }
 *             
 *   instance: 모든 데이터나 메서드 호출이 가능
 */

/*
 * 생성자: 여러개를 만들 수 있다(사용자보루터 멤버변수의 초기값을 받아서 사용)
 *        => 오버로딩을 지원한다
 *        => 초기화를 담당한다
 *        => 리턴형이 없다(return은 사용이 가능)
 *        => 클래스명과 동일 (대소문자 구분)
 *        => 존재하지 않는 경우에 컴파일러가 자동으로 디폴트 생성자(매개변수가 없는 생성자) 추가
 *       
 *       
 *       
 *       ***
 *       클래스
 *       ======
 *       1. 일반 클래스
 *          public class MainClass {}
 *       2. 추상 클래스 (설계)
 *          public abstract class MainClass {}
 *		 3. 종단 클래스
 *			public final class MainClass: 확장이 불가능한 클래스
 *          => String, Math, System
 *       4. 내부 클래스
 *          class A {
 *              class B { => 쓰레드, 네트워크
 *              
 *              }
 *          }
 *
 *
 */
// 기존의 클래스 상속 => this(): 자신의 생성자를 호출할 수 있다.

/*
상위 클래스를 제어할 때 suer, super()
 자신의 클래스를 제어할 때: this, this()                      
*/

import javax.swing.JFrame;
import javax.swing.*;

public class MainClass extends JFrame {

	public MainClass() {
		super("Hello"); // JFrame의 생성자 함수 => 상위 클래스(상속을 내리는 클래스)의 생성자를 호출
		setSize(640, 480);// 윈도우 크기
		setVisible(true); // 윈도우 보여주기
	}

	public MainClass(int width, int height) {
//		this(); // 생성자를 호출할 때 반드시 첫번째 줄에 코딩해야한다.
		setSize(width, height);// 윈도우 크기
		setVisible(true);
	}

	public static void main(String[] args) {

		// 생성자만 호출
		new MainClass(600, 800);

	}

}
